{
  "__document_status__": "Active",
  "id": "19",
  "name": "Loopar Concepts",
  "module": "loopar-web",
  "doc_structure": "[{\"element\":\"menu_content\",\"data\":{\"label\":\"Concepts\",\"key\":\"concepts_menu_content\",\"id\":\"concepts_menu_content\",\"name\":\"concepts_menu_content\"},\"elements\":[{\"element\":\"markdown\",\"data\":{\"label\":\"Overview\",\"key\":\"md_overview\",\"id\":\"overview\",\"name\":\"md_overview\",\"value\":\"# Concepts Overview\\n\\nLoopar is a **meta-framework** — a framework that can build itself. At its core lies a powerful concept: **Entity**, the master builder that creates other builders.\\n\\n---\\n\\n## The Philosophy\\n\\nTraditional frameworks require you to write code for every model, view, and controller. Loopar inverts this: you **define** what you want, and the framework **generates** everything else.\\n\\n```\\n┌─────────────────────────────────────────────────────────────┐\\n│                    THE LOOPAR WAY                           │\\n├─────────────────────────────────────────────────────────────┤\\n│                                                             │\\n│   Traditional:  Code → Application                          │\\n│                                                             │\\n│   Loopar:       Definition → Code → Application             │\\n│                      ↑                                      │\\n│                 (drag & drop)                               │\\n│                                                             │\\n└─────────────────────────────────────────────────────────────┘\\n```\\n\\n---\\n\\n## Core Concepts\\n\\n| Concept | Description |\\n|---------|-------------|\\n| **Entity** | The master builder — defines data models and generates everything |\\n| **Builder** | Specialized entity types (Page, View, Form, Controller) |\\n| **App** | A self-contained application package |\\n| **Module** | Groups related entities within an app |\\n| **Document** | A data-centric entity (stored in database) |\\n| **Page** | A presentation-centric entity (web pages) |\\n| **Component** | UI elements used in drag-and-drop design |\\n\\n---\\n\\n## The Auto-Recursive Magic\\n\\nWhat makes Loopar unique is that **Entity is built using Entity**. The system bootstraps itself:\\n\\n1. Entity defines the structure of all models\\n2. Entity creates Builders (specialized entity types)\\n3. Builders create specific model types (Pages, Forms, Views)\\n4. You use Builders to create your application\\n\\nThis means you can extend Loopar using Loopar itself.\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Entity\",\"key\":\"md_entity\",\"id\":\"entity\",\"name\":\"md_entity\",\"value\":\"# Entity\\n\\n**Entity** is the foundational concept in Loopar. It's the master builder that defines data models and automatically generates all the code needed to work with them.\\n\\n---\\n\\n## What Entity Creates\\n\\nWhen you define an Entity, Loopar automatically generates:\\n\\n| Generated | Description |\\n|-----------|-------------|\\n| **Database Table** | With proper schema and migrations |\\n| **Sequelize Model** | ORM model with validations |\\n| **REST API** | Full CRUD endpoints |\\n| **React Form** | With all field types rendered |\\n| **List View** | With search, filters, and pagination |\\n| **Controller** | With lifecycle hooks |\\n\\n---\\n\\n## Entity Structure\\n\\nEvery Entity consists of three optional files:\\n\\n```\\n/modules/[module-name]/[entity-name]/\\n├── entity-name.json      # Field definitions & metadata\\n├── entity-name.js        # Server-side controller (optional)\\n└── entity-name.jsx       # Client-side component (optional)\\n```\\n\\n### The JSON File (Required)\\n\\nDefines the entity's fields, metadata, and structure:\\n\\n```json\\n{\\n  \\\"name\\\": \\\"Customer\\\",\\n  \\\"module\\\": \\\"CRM\\\",\\n  \\\"is_single\\\": false,\\n  \\\"fields\\\": [\\n    { \\\"name\\\": \\\"name\\\", \\\"type\\\": \\\"Data\\\", \\\"required\\\": true },\\n    { \\\"name\\\": \\\"email\\\", \\\"type\\\": \\\"Email\\\", \\\"unique\\\": true },\\n    { \\\"name\\\": \\\"status\\\", \\\"type\\\": \\\"Select\\\", \\n      \\\"options\\\": [\\\"Lead\\\", \\\"Active\\\", \\\"Inactive\\\"] }\\n  ]\\n}\\n```\\n\\n### The JS File (Optional)\\n\\nServer-side controller for custom business logic:\\n\\n```javascript\\nimport { BaseDocument } from \\\"loopar\\\";\\n\\nexport default class Customer extends BaseDocument {\\n  constructor(props) {\\n    super(props);\\n  }\\n\\n  async beforeInsert() {\\n    // Runs before saving a new record\\n    this.created_at = new Date();\\n  }\\n\\n  async afterInsert() {\\n    // Runs after saving a new record\\n    await this.sendWelcomeEmail();\\n  }\\n\\n  async validate() {\\n    if (!this.email.includes('@')) {\\n      throw new Error('Invalid email format');\\n    }\\n  }\\n}\\n```\\n\\n### The JSX File (Optional)\\n\\nClient-side React component for custom UI:\\n\\n```jsx\\nimport { BaseForm } from \\\"@loopar/components\\\";\\n\\nexport default function CustomerForm(props) {\\n  return (\\n    <BaseForm {...props}>\\n      {/* Custom UI elements */}\\n    </BaseForm>\\n  );\\n}\\n```\\n\\n---\\n\\n## Entity Types\\n\\n| Type | `is_single` | Description |\\n|------|-------------|-------------|\\n| **Document** | `false` | Multiple records (customers, products) |\\n| **Single** | `true` | One record only (settings, config) |\\n\\n---\\n\\n## Document vs Single\\n\\n**Document** entities store multiple records:\\n- Customer, Product, Order, Invoice\\n- Have list views with pagination\\n- CRUD operations on individual records\\n\\n**Single** entities store only one record:\\n- System Settings, Company Info, App Config\\n- No list view, direct access to the form\\n- Perfect for configuration data\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Builders\",\"key\":\"md_builders\",\"id\":\"builders\",\"name\":\"md_builders\",\"value\":\"# Builders\\n\\n**Builders** are specialized entities designed to create specific types of models. While Entity is the general-purpose builder, each Builder is optimized for a particular use case.\\n\\n---\\n\\n## Why Builders?\\n\\nEntity is powerful but generic. Builders provide:\\n\\n- **Focused metadata** — Only relevant fields for the model type\\n- **Optimized UI** — Tailored design experience\\n- **Specialized behavior** — Logic specific to the model type\\n\\n---\\n\\n## Builder Types\\n\\n### Page Builder\\n\\nCreates complete web pages: homepages, landing pages, blogs, documentation.\\n\\n| Feature | Description |\\n|---------|-------------|\\n| **Purpose** | Design full web pages visually |\\n| **Output** | Standalone page with route |\\n| **Components** | Sections, rows, columns, text, images, etc. |\\n| **Use Cases** | Homepage, About, Contact, Blog posts |\\n\\n```\\n/pages/homepage/\\n├── homepage.json       # Page structure & components\\n├── homepage.js         # Page controller (optional)\\n└── homepage.jsx        # Custom React component (optional)\\n```\\n\\n---\\n\\n### View Builder\\n\\nCreates data display components that connect to a model.\\n\\n| Feature | Description |\\n|---------|-------------|\\n| **Purpose** | Visualize data from an entity |\\n| **Output** | Connected view component |\\n| **Components** | Tables, cards, charts, grids |\\n| **Use Cases** | Dashboards, reports, data displays |\\n\\nViews connect to a source entity and render its data with custom layouts.\\n\\n---\\n\\n### Form Builder\\n\\nCreates forms for data collection without requiring a full entity.\\n\\n| Feature | Description |\\n|---------|-------------|\\n| **Purpose** | Collect and submit data |\\n| **Output** | Form that submits to a controller |\\n| **Components** | Inputs, selects, checkboxes, buttons |\\n| **Use Cases** | Login, registration, contact forms |\\n\\n```\\n/forms/login-form/\\n├── login-form.json     # Form fields & layout\\n└── login-form.js       # Form submission handler\\n```\\n\\n---\\n\\n### Controller Builder\\n\\nCreates server-side controllers for custom actions without a model.\\n\\n| Feature | Description |\\n|---------|-------------|\\n| **Purpose** | Handle specific backend actions |\\n| **Output** | API routes and actions |\\n| **Components** | N/A (server-side only) |\\n| **Use Cases** | Auth endpoints, webhooks, integrations |\\n\\n```javascript\\n// login-controller.js\\nexport default class LoginController extends BaseController {\\n  async actionLogin() {\\n    const { email, password } = this.request.body;\\n    // Authentication logic\\n  }\\n\\n  async actionLogout() {\\n    // Logout logic\\n  }\\n}\\n```\\n\\n---\\n\\n## Choosing the Right Builder\\n\\n| Need | Builder |\\n|------|--------|\\n| Database model with CRUD | **Entity** |\\n| Web page design | **Page Builder** |\\n| Display existing data | **View Builder** |\\n| Standalone form | **Form Builder** |\\n| Custom API endpoints | **Controller Builder** |\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"App\",\"key\":\"md_app\",\"id\":\"app\",\"name\":\"md_app\",\"value\":\"# App\\n\\n**App** is Loopar's packaging system. An App is a self-contained application that bundles modules, entities, pages, and assets into an installable unit.\\n\\n---\\n\\n## What is an App?\\n\\nThink of an App as an independent program within Loopar:\\n\\n- Contains all its modules and entities\\n- Can be installed/uninstalled on any tenant\\n- Can be shared, distributed, or sold\\n- Has its own version and dependencies\\n\\n---\\n\\n## App Structure\\n\\n```\\n/apps/\\n└── my-crm/                      # App directory\\n    ├── app.json                 # App metadata\\n    ├── modules/                 # App modules\\n    │   ├── contacts/            # Module: Contacts\\n    │   │   ├── customer/        # Entity: Customer\\n    │   │   │   ├── customer.json\\n    │   │   │   ├── customer.js\\n    │   │   │   └── customer.jsx\\n    │   │   └── lead/            # Entity: Lead\\n    │   │       └── lead.json\\n    │   └── sales/               # Module: Sales\\n    │       ├── quote/\\n    │       └── invoice/\\n    └── public/                  # Static assets\\n        ├── images/\\n        └── styles/\\n```\\n\\n---\\n\\n## App Metadata (app.json)\\n\\n```json\\n{\\n  \\\"name\\\": \\\"My CRM\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"Customer relationship management app\\\",\\n  \\\"author\\\": \\\"Your Name\\\",\\n  \\\"dependencies\\\": [\\\"loopar\\\"],\\n  \\\"modules\\\": [\\\"contacts\\\", \\\"sales\\\"]\\n}\\n```\\n\\n---\\n\\n## App Lifecycle\\n\\n```\\n┌──────────────┐     ┌──────────────┐     ┌──────────────┐\\n│    Create    │ →   │   Develop    │ →   │   Install    │\\n│   (in dev)   │     │  (add models)│     │ (on tenant)  │\\n└──────────────┘     └──────────────┘     └──────────────┘\\n                                                 ↓\\n┌──────────────┐     ┌──────────────┐     ┌──────────────┐\\n│   Publish    │ ←   │    Export    │ ←   │    Test      │\\n│ (marketplace)│     │   (package)  │     │  (staging)   │\\n└──────────────┘     └──────────────┘     └──────────────┘\\n```\\n\\n---\\n\\n## App Manager\\n\\nAccess the App Manager at `desk/App Manager/view` to:\\n\\n| Action | Description |\\n|--------|-------------|\\n| **Create** | Start a new app |\\n| **Install** | Install app on current tenant |\\n| **Uninstall** | Remove app from tenant |\\n| **Update** | Update to newer version |\\n| **Export** | Package app for distribution |\\n| **Import** | Install from repository or file |\\n\\n---\\n\\n## Default App Creation\\n\\nWhen you create an App, Loopar automatically:\\n\\n1. Creates the app directory structure\\n2. Generates a module with the same name\\n3. Sets up the app.json metadata\\n4. Registers the app in the system\\n\\nAll entities you create are linked to the app through their module.\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Module\",\"key\":\"md_module\",\"id\":\"module\",\"name\":\"md_module\",\"value\":\"# Module\\n\\n**Module** is Loopar's organizational unit. Modules group related entities within an app, providing logical separation and structure.\\n\\n---\\n\\n## What is a Module?\\n\\nA Module is like a folder that contains related functionality:\\n\\n- Groups entities by domain (sales, inventory, HR)\\n- Provides namespace isolation\\n- Enables selective installation\\n- Organizes the Desk sidebar\\n\\n---\\n\\n## Module Structure\\n\\n```\\n/apps/my-app/modules/\\n├── core/                    # Core functionality\\n│   ├── user/\\n│   ├── role/\\n│   └── settings/\\n├── sales/                   # Sales module\\n│   ├── customer/\\n│   ├── quote/\\n│   └── invoice/\\n└── inventory/               # Inventory module\\n    ├── product/\\n    ├── warehouse/\\n    └── stock-entry/\\n```\\n\\n---\\n\\n## Module in the Desk\\n\\nModules appear in the Desk sidebar, grouping their entities:\\n\\n```\\n┌─────────────────────────────┐\\n│  DESK                       │\\n├─────────────────────────────┤\\n│  ▼ Core                     │\\n│      Users                  │\\n│      Roles                  │\\n│      Settings               │\\n│  ▼ Sales                    │\\n│      Customers              │\\n│      Quotes                 │\\n│      Invoices               │\\n│  ▼ Inventory                │\\n│      Products               │\\n│      Warehouses             │\\n│      Stock Entries          │\\n└─────────────────────────────┘\\n```\\n\\n---\\n\\n## Creating a Module\\n\\n1. Go to **Desk** → **Module** → **New**\\n2. Enter module details:\\n   - **Name**: Module identifier (e.g., `sales`)\\n   - **Label**: Display name (e.g., `Sales`)\\n   - **App**: Parent app\\n   - **Icon**: Module icon for the sidebar\\n3. Save the module\\n\\n---\\n\\n## Module vs App\\n\\n| Aspect | App | Module |\\n|--------|-----|--------|\\n| **Scope** | Complete application | Functional group |\\n| **Contains** | Modules, assets, config | Entities only |\\n| **Installable** | Yes | No (part of app) |\\n| **Example** | CRM App | Sales Module |\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Fields & Components\",\"key\":\"md_fields\",\"id\":\"fields\",\"name\":\"md_fields\",\"value\":\"# Fields & Components\\n\\nLoopar provides a rich set of field types and UI components for building your entities and pages.\\n\\n---\\n\\n## Data Fields\\n\\nFields that store data in the database:\\n\\n| Field Type | Description | Database Type |\\n|------------|-------------|---------------|\\n| **Data** | Single line text | VARCHAR(255) |\\n| **Text** | Multi-line text | TEXT |\\n| **Int** | Integer number | INT |\\n| **Float** | Decimal number | FLOAT |\\n| **Currency** | Money values | DECIMAL(18,6) |\\n| **Date** | Date only | DATE |\\n| **DateTime** | Date and time | DATETIME |\\n| **Time** | Time only | TIME |\\n| **Check** | Boolean (yes/no) | TINYINT(1) |\\n| **Select** | Dropdown options | VARCHAR(255) |\\n| **Link** | Reference to another entity | VARCHAR(255) |\\n| **Table** | Child table (one-to-many) | — |\\n| **Email** | Email with validation | VARCHAR(255) |\\n| **Phone** | Phone number | VARCHAR(50) |\\n| **Password** | Encrypted password | VARCHAR(255) |\\n| **Color** | Color picker | VARCHAR(20) |\\n| **Image** | Image upload | TEXT (path) |\\n| **File** | File upload | TEXT (path) |\\n| **Markdown** | Rich markdown text | LONGTEXT |\\n| **Code** | Code editor | LONGTEXT |\\n| **JSON** | JSON data | LONGTEXT |\\n\\n---\\n\\n## Layout Components\\n\\nComponents for structuring pages (no database storage):\\n\\n| Component | Description |\\n|-----------|-------------|\\n| **Section** | Full-width container |\\n| **Row** | Horizontal container with columns |\\n| **Col** | Column within a row |\\n| **Panel** | Card-like container with styling |\\n| **Div** | Generic container |\\n| **Tab** | Tabbed content container |\\n| **Collapse** | Collapsible content |\\n\\n---\\n\\n## Display Components\\n\\n| Component | Description |\\n|-----------|-------------|\\n| **Title** | Heading text (h1-h6) |\\n| **Subtitle** | Secondary heading |\\n| **Paragraph** | Body text |\\n| **Image** | Display image |\\n| **Icon** | Lucide icon |\\n| **Button** | Clickable button |\\n| **Link** | Navigation link |\\n| **Markdown** | Rendered markdown |\\n| **Code Block** | Syntax-highlighted code |\\n\\n---\\n\\n## Interactive Components\\n\\n| Component | Description |\\n|-----------|-------------|\\n| **Carousel** | Image/content slider |\\n| **Particles** | Animated particle background |\\n| **Banner Image** | Hero banner with overlay |\\n| **Feature Card** | Feature highlight card |\\n| **Pricing Card** | Pricing table card |\\n| **Testimonial** | Customer testimonial |\\n\\n---\\n\\n## Field Properties\\n\\nCommon properties available on most fields:\\n\\n| Property | Description |\\n|----------|-------------|\\n| `name` | Field identifier (snake_case) |\\n| `label` | Display label |\\n| `type` | Field type |\\n| `required` | Must have a value |\\n| `unique` | Must be unique in database |\\n| `default` | Default value |\\n| `hidden` | Hide from UI |\\n| `readonly` | Cannot be edited |\\n| `options` | For Select fields |\\n| `description` | Help text |\\n| `class` | CSS classes |\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Lifecycle Hooks\",\"key\":\"md_lifecycle\",\"id\":\"lifecycle\",\"name\":\"md_lifecycle\",\"value\":\"# Lifecycle Hooks\\n\\nLoopar provides hooks at key points in an entity's lifecycle. Use these to add custom business logic.\\n\\n---\\n\\n## Server-Side Hooks\\n\\nDefined in the entity's `.js` file:\\n\\n```javascript\\nimport { BaseDocument } from \\\"loopar\\\";\\n\\nexport default class Invoice extends BaseDocument {\\n  \\n  // ═══════════════════════════════════════\\n  // VALIDATION\\n  // ═══════════════════════════════════════\\n  \\n  async validate() {\\n    // Runs before any save operation\\n    // Throw error to prevent save\\n    if (this.total < 0) {\\n      throw new Error(\\\"Total cannot be negative\\\");\\n    }\\n  }\\n\\n  // ═══════════════════════════════════════\\n  // INSERT HOOKS (new records)\\n  // ═══════════════════════════════════════\\n  \\n  async beforeInsert() {\\n    // Before saving new record\\n    this.created_by = this.session.user;\\n    this.status = \\\"Draft\\\";\\n  }\\n\\n  async afterInsert() {\\n    // After saving new record\\n    await this.notifyAccountant();\\n  }\\n\\n  // ═══════════════════════════════════════\\n  // UPDATE HOOKS (existing records)\\n  // ═══════════════════════════════════════\\n  \\n  async beforeUpdate() {\\n    // Before updating existing record\\n    this.modified_by = this.session.user;\\n  }\\n\\n  async afterUpdate() {\\n    // After updating existing record\\n    if (this.status === \\\"Paid\\\") {\\n      await this.updateCustomerBalance();\\n    }\\n  }\\n\\n  // ═══════════════════════════════════════\\n  // SAVE HOOKS (both insert and update)\\n  // ═══════════════════════════════════════\\n  \\n  async beforeSave() {\\n    // Before any save (insert or update)\\n    this.calculateTotals();\\n  }\\n\\n  async afterSave() {\\n    // After any save (insert or update)\\n    await this.updateStockLevels();\\n  }\\n\\n  // ═══════════════════════════════════════\\n  // DELETE HOOKS\\n  // ═══════════════════════════════════════\\n  \\n  async beforeDelete() {\\n    // Before deleting record\\n    if (this.status === \\\"Paid\\\") {\\n      throw new Error(\\\"Cannot delete paid invoice\\\");\\n    }\\n  }\\n\\n  async afterDelete() {\\n    // After deleting record\\n    await this.reverseStockEntries();\\n  }\\n}\\n```\\n\\n---\\n\\n## Hook Execution Order\\n\\n### On Insert (new record)\\n\\n```\\n1. validate()\\n2. beforeSave()\\n3. beforeInsert()\\n4. → DATABASE INSERT →\\n5. afterInsert()\\n6. afterSave()\\n```\\n\\n### On Update (existing record)\\n\\n```\\n1. validate()\\n2. beforeSave()\\n3. beforeUpdate()\\n4. → DATABASE UPDATE →\\n5. afterUpdate()\\n6. afterSave()\\n```\\n\\n### On Delete\\n\\n```\\n1. beforeDelete()\\n2. → DATABASE DELETE →\\n3. afterDelete()\\n```\\n\\n---\\n\\n## Accessing Data in Hooks\\n\\n```javascript\\nasync beforeSave() {\\n  // Access field values\\n  const customerName = this.customer_name;\\n  \\n  // Access session/user info\\n  const currentUser = this.session.user;\\n  \\n  // Access request data\\n  const requestBody = this.request?.body;\\n  \\n  // Query other documents\\n  const customer = await loopar.getDocument(\\\"Customer\\\", this.customer);\\n  \\n  // Set field values\\n  this.total = this.calculateTotal();\\n}\\n```\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Client vs Server\",\"key\":\"md_client_server\",\"id\":\"client-server\",\"name\":\"md_client_server\",\"value\":\"# Client vs Server\\n\\nLoopar separates client-side and server-side code clearly. Understanding this separation is key to extending the framework.\\n\\n---\\n\\n## File Responsibilities\\n\\n```\\n/entity-name/\\n├── entity-name.json    → Definition (shared)\\n├── entity-name.js      → Server-side (Node.js)\\n└── entity-name.jsx     → Client-side (React)\\n```\\n\\n| File | Runs On | Purpose |\\n|------|---------|--------|\\n| `.json` | Both | Field definitions, metadata |\\n| `.js` | Server | Business logic, database, API |\\n| `.jsx` | Client | UI components, interactions |\\n\\n---\\n\\n## Server-Side (.js)\\n\\nRuns in Node.js. Has access to:\\n\\n- Database operations\\n- File system\\n- Environment variables\\n- External APIs (server-to-server)\\n- Session and authentication\\n- Business logic hooks\\n\\n```javascript\\n// entity-name.js\\nimport { BaseDocument } from \\\"loopar\\\";\\n\\nexport default class MyEntity extends BaseDocument {\\n  async beforeSave() {\\n    // Database access\\n    const count = await loopar.db.count(\\\"Customer\\\");\\n    \\n    // File system\\n    const config = await loopar.readFile(\\\"config.json\\\");\\n    \\n    // Environment\\n    const apiKey = process.env.API_KEY;\\n  }\\n\\n  // Custom API action\\n  async actionCustomEndpoint() {\\n    return { success: true, data: this.getData() };\\n  }\\n}\\n```\\n\\n---\\n\\n## Client-Side (.jsx)\\n\\nRuns in the browser (React). Has access to:\\n\\n- UI rendering\\n- User interactions\\n- Browser APIs\\n- HTTP requests to server\\n- Component state\\n\\n```jsx\\n// entity-name.jsx\\nimport { BaseForm, useDocument } from \\\"@loopar/components\\\";\\nimport { useState } from \\\"react\\\";\\n\\nexport default function MyEntity(props) {\\n  const { document, setValue } = useDocument();\\n  const [loading, setLoading] = useState(false);\\n\\n  const handleCustomAction = async () => {\\n    setLoading(true);\\n    const response = await fetch(`/api/my-entity/custom-endpoint`);\\n    setLoading(false);\\n  };\\n\\n  return (\\n    <BaseForm {...props}>\\n      <button onClick={handleCustomAction}>\\n        {loading ? \\\"Loading...\\\" : \\\"Custom Action\\\"}\\n      </button>\\n    </BaseForm>\\n  );\\n}\\n```\\n\\n---\\n\\n## Communication Between Client & Server\\n\\n```\\n┌─────────────────┐         ┌─────────────────┐\\n│     CLIENT      │         │     SERVER      │\\n│    (Browser)    │         │    (Node.js)    │\\n├─────────────────┤         ├─────────────────┤\\n│                 │  HTTP   │                 │\\n│  React Component│ ──────→ │  Controller     │\\n│  (.jsx)         │ Request │  (.js)          │\\n│                 │         │                 │\\n│                 │ ←────── │                 │\\n│                 │ Response│                 │\\n└─────────────────┘         └─────────────────┘\\n```\\n\\n---\\n\\n## When to Use Each\\n\\n| Use Server (.js) For | Use Client (.jsx) For |\\n|---------------------|----------------------|\\n| Database queries | UI customization |\\n| Data validation | User interactions |\\n| Business rules | Form behavior |\\n| API integrations | Animations |\\n| File operations | Conditional rendering |\\n| Authentication | Real-time updates |\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Multi-Tenant\",\"key\":\"md_multitenant\",\"id\":\"multitenant\",\"name\":\"md_multitenant\",\"value\":\"# Multi-Tenant Architecture\\n\\nLoopar's multi-tenant system allows you to run multiple isolated sites from a single codebase.\\n\\n---\\n\\n## What is Multi-Tenancy?\\n\\nEach tenant is a completely independent site with:\\n\\n- **Own database** — Complete data isolation\\n- **Own domain** — Custom URL for each client\\n- **Own config** — Independent settings\\n- **Own users** — Separate user base\\n- **Shared code** — Same apps, different data\\n\\n---\\n\\n## Architecture\\n\\n```\\n┌─────────────────────────────────────────────────────────────┐\\n│                      SINGLE CODEBASE                        │\\n│                       /apps, /packages                       │\\n├─────────────────────────────────────────────────────────────┤\\n│                                                             │\\n│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐     │\\n│  │   TENANT A    │ │   TENANT B    │ │   TENANT C    │     │\\n│  │   (dev)       │ │  (client-1)   │ │  (client-2)   │     │\\n│  ├───────────────┤ ├───────────────┤ ├───────────────┤     │\\n│  │ Database: dev │ │ Database: c1  │ │ Database: c2  │     │\\n│  │ Port: 3000    │ │ Port: 3001    │ │ Port: 3002    │     │\\n│  │ Domain: —     │ │ app1.com      │ │ app2.com      │     │\\n│  └───────────────┘ └───────────────┘ └───────────────┘     │\\n│         │                 │                 │               │\\n│         └────────────┬────┴────────────────┘               │\\n│                      │                                      │\\n│                    PM2                                      │\\n│            (Process Manager)                                │\\n│                      │                                      │\\n│                   CADDY                                     │\\n│         (Reverse Proxy + SSL)                               │\\n│                                                             │\\n└─────────────────────────────────────────────────────────────┘\\n```\\n\\n---\\n\\n## Site Directory Structure\\n\\n```\\n/sites/\\n├── dev/                    # Development tenant\\n│   ├── .env                # Environment config\\n│   ├── installed-apps.json # Installed apps list\\n│   ├── public/\\n│   │   └── uploads/        # Tenant-specific uploads\\n│   └── sessions/           # User sessions\\n│\\n├── client-1/               # Production tenant\\n│   ├── .env\\n│   ├── installed-apps.json\\n│   └── ...\\n│\\n└── client-2/               # Another tenant\\n    └── ...\\n```\\n\\n---\\n\\n## Tenant Configuration (.env)\\n\\nEach tenant has its own environment file:\\n\\n```bash\\n# sites/client-1/.env\\nDB_TYPE=mysql\\nDB_HOST=localhost\\nDB_NAME=client1_db\\nDB_USER=client1\\nDB_PASSWORD=secret\\n\\nPORT=3001\\nNODE_ENV=production\\n\\nDOMAIN=app1.com\\n```\\n\\n---\\n\\n## Use Cases\\n\\n| Scenario | Setup |\\n|----------|-------|\\n| **SaaS Product** | One tenant per customer |\\n| **Agency** | One tenant per client project |\\n| **Enterprise** | Separate tenants for departments |\\n| **Staging** | Dev, Staging, Production tenants |\\n\\n---\\n\\n## Key Benefits\\n\\n| Benefit | Description |\\n|---------|-------------|\\n| **Data Isolation** | Each client's data is completely separate |\\n| **Custom Domains** | Professional URLs for each client |\\n| **Independent Scaling** | Scale individual tenants as needed |\\n| **Easy Deployment** | Deploy updates to all tenants at once |\\n| **Cost Efficient** | Single server, multiple clients |\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"API & Routes\",\"key\":\"md_api\",\"id\":\"api\",\"name\":\"md_api\",\"value\":\"# API & Routes\\n\\nLoopar automatically generates RESTful API endpoints for every entity. You can also create custom actions.\\n\\n---\\n\\n## Auto-Generated Endpoints\\n\\nFor an entity named `Customer`, Loopar creates:\\n\\n| Method | Endpoint | Action |\\n|--------|----------|--------|\\n| `GET` | `/api/Customer` | List all records |\\n| `GET` | `/api/Customer/:name` | Get single record |\\n| `POST` | `/api/Customer` | Create new record |\\n| `PUT` | `/api/Customer/:name` | Update record |\\n| `DELETE` | `/api/Customer/:name` | Delete record |\\n\\n---\\n\\n## Query Parameters\\n\\nThe list endpoint supports:\\n\\n```bash\\n# Pagination\\nGET /api/Customer?page=1&limit=20\\n\\n# Search\\nGET /api/Customer?search=john\\n\\n# Filters\\nGET /api/Customer?status=Active&country=USA\\n\\n# Sorting\\nGET /api/Customer?order_by=created_at&order=desc\\n\\n# Field selection\\nGET /api/Customer?fields=name,email,status\\n```\\n\\n---\\n\\n## Custom Actions\\n\\nAdd custom API endpoints in your entity's `.js` file:\\n\\n```javascript\\nexport default class Customer extends BaseDocument {\\n  \\n  // Creates: POST /api/Customer/send-welcome-email\\n  async actionSendWelcomeEmail() {\\n    await this.sendEmail({\\n      to: this.email,\\n      subject: \\\"Welcome!\\\",\\n      template: \\\"welcome\\\"\\n    });\\n    \\n    return {\\n      success: true,\\n      message: \\\"Email sent successfully\\\"\\n    };\\n  }\\n\\n  // Creates: GET /api/Customer/stats\\n  async actionStats() {\\n    const total = await loopar.db.count(\\\"Customer\\\");\\n    const active = await loopar.db.count(\\\"Customer\\\", { status: \\\"Active\\\" });\\n    \\n    return {\\n      total,\\n      active,\\n      inactive: total - active\\n    };\\n  }\\n}\\n```\\n\\n---\\n\\n## Calling Actions from Client\\n\\n```javascript\\n// From React component\\nconst response = await fetch(\\\"/api/Customer/send-welcome-email\\\", {\\n  method: \\\"POST\\\",\\n  headers: { \\\"Content-Type\\\": \\\"application/json\\\" },\\n  body: JSON.stringify({ name: \\\"CUST-001\\\" })\\n});\\n\\nconst data = await response.json();\\n```\\n\\n---\\n\\n## Page Routes\\n\\nPages get their own routes automatically:\\n\\n| Page Name | Route |\\n|-----------|-------|\\n| `homepage` | `/homepage` |\\n| `about-us` | `/about-us` |\\n| `contact` | `/contact` |\\n\\n---\\n\\n## Desk Routes\\n\\nInternal desk routes follow this pattern:\\n\\n| Route | View |\\n|-------|------|\\n| `/desk/Customer/list` | List view |\\n| `/desk/Customer/new` | New record form |\\n| `/desk/Customer/edit/:name` | Edit record form |\\n| `/desk/Customer/view/:name` | Read-only view |\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Database\",\"key\":\"md_database\",\"id\":\"database\",\"name\":\"md_database\",\"value\":\"# Database\\n\\nLoopar uses Sequelize ORM to support multiple database backends. The schema is generated automatically from your entity definitions.\\n\\n---\\n\\n## Supported Databases\\n\\n| Database | Best For |\\n|----------|----------|\\n| **MySQL** | Production, high performance |\\n| **PostgreSQL** | Advanced features, JSON support |\\n| **MariaDB** | MySQL alternative |\\n| **SQLite** | Development, small deployments |\\n\\n---\\n\\n## Automatic Schema Management\\n\\nWhen you create or modify an entity:\\n\\n1. Loopar reads the field definitions from `.json`\\n2. Compares with current database schema\\n3. Generates migration SQL\\n4. Applies changes automatically\\n\\n```\\nEntity Definition → Schema Diff → Migration → Database\\n```\\n\\n---\\n\\n## Field to Column Mapping\\n\\n| Field Type | MySQL | PostgreSQL |\\n|------------|-------|------------|\\n| Data | VARCHAR(255) | VARCHAR(255) |\\n| Text | TEXT | TEXT |\\n| Int | INT | INTEGER |\\n| Float | FLOAT | REAL |\\n| Currency | DECIMAL(18,6) | NUMERIC(18,6) |\\n| Date | DATE | DATE |\\n| DateTime | DATETIME | TIMESTAMP |\\n| Check | TINYINT(1) | BOOLEAN |\\n| JSON | LONGTEXT | JSONB |\\n\\n---\\n\\n## Database API\\n\\nAccess the database in server-side code:\\n\\n```javascript\\nimport loopar from \\\"loopar\\\";\\n\\n// Get a document\\nconst customer = await loopar.getDocument(\\\"Customer\\\", \\\"CUST-001\\\");\\n\\n// Create a document\\nconst newCustomer = await loopar.newDocument(\\\"Customer\\\");\\nnewCustomer.name = \\\"John Doe\\\";\\nnewCustomer.email = \\\"john@example.com\\\";\\nawait newCustomer.save();\\n\\n// Query documents\\nconst customers = await loopar.db.getAll(\\\"Customer\\\", {\\n  filters: { status: \\\"Active\\\" },\\n  fields: [\\\"name\\\", \\\"email\\\"],\\n  orderBy: \\\"created_at DESC\\\",\\n  limit: 10\\n});\\n\\n// Count documents\\nconst count = await loopar.db.count(\\\"Customer\\\", { status: \\\"Active\\\" });\\n\\n// Raw SQL (when needed)\\nconst results = await loopar.db.execute(\\n  \\\"SELECT * FROM Customer WHERE created_at > ?\\\",\\n  [\\\"2024-01-01\\\"]\\n);\\n```\\n\\n---\\n\\n## Relationships\\n\\n### Link Fields (Many-to-One)\\n\\n```json\\n{\\n  \\\"name\\\": \\\"customer\\\",\\n  \\\"type\\\": \\\"Link\\\",\\n  \\\"options\\\": \\\"Customer\\\"\\n}\\n```\\n\\nCreates a foreign key reference to the Customer entity.\\n\\n### Table Fields (One-to-Many)\\n\\n```json\\n{\\n  \\\"name\\\": \\\"items\\\",\\n  \\\"type\\\": \\\"Table\\\",\\n  \\\"options\\\": \\\"Invoice Item\\\"\\n}\\n```\\n\\nCreates a child table with parent reference.\\n\\n---\\n\\n## Database Per Tenant\\n\\nEach tenant has its own database:\\n\\n```\\n┌─────────────┐    ┌─────────────┐    ┌─────────────┐\\n│  Tenant A   │    │  Tenant B   │    │  Tenant C   │\\n│             │    │             │    │             │\\n│  ┌───────┐  │    │  ┌───────┐  │    │  ┌───────┐  │\\n│  │ MySQL │  │    │ │ MySQL │  │    │ │SQLite │  │\\n│  │ db_a  │  │    │  │ db_b  │  │    │  │ db_c  │  │\\n│  └───────┘  │    │  └───────┘  │    │  └───────┘  │\\n└─────────────┘    └─────────────┘    └─────────────┘\\n```\\n\\nEach tenant can even use a different database type.\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Theming\",\"key\":\"md_theming\",\"id\":\"theming\",\"name\":\"md_theming\",\"value\":\"# Theming\\n\\nLoopar uses Tailwind CSS with CSS variables for a flexible theming system. Themes can be changed dynamically without rebuilds.\\n\\n---\\n\\n## Theme System\\n\\nLoopar supports:\\n\\n- **Light/Dark modes** — Automatic switching\\n- **Custom color schemes** — Define your brand colors\\n- **Per-tenant themes** — Each tenant can have its own theme\\n- **Dynamic generation** — Create themes programmatically\\n\\n---\\n\\n## CSS Variables\\n\\nThemes are defined using CSS custom properties:\\n\\n```css\\n:root {\\n  --background: 0 0% 100%;\\n  --foreground: 222 84% 5%;\\n  --primary: 221 83% 53%;\\n  --primary-foreground: 210 40% 98%;\\n  --secondary: 210 40% 96%;\\n  --muted: 210 40% 96%;\\n  --accent: 210 40% 96%;\\n  --destructive: 0 84% 60%;\\n  --border: 214 32% 91%;\\n  --radius: 0.5rem;\\n}\\n\\n.dark {\\n  --background: 222 84% 5%;\\n  --foreground: 210 40% 98%;\\n  /* ... dark mode colors */\\n}\\n```\\n\\n---\\n\\n## Using Theme Colors\\n\\nIn your components, use Tailwind classes:\\n\\n```jsx\\n// Background colors\\n<div className=\\\"bg-background\\\" />\\n<div className=\\\"bg-primary\\\" />\\n<div className=\\\"bg-secondary\\\" />\\n\\n// Text colors\\n<p className=\\\"text-foreground\\\" />\\n<p className=\\\"text-muted-foreground\\\" />\\n<p className=\\\"text-primary\\\" />\\n\\n// Border colors\\n<div className=\\\"border border-border\\\" />\\n```\\n\\n---\\n\\n## Built-in Themes\\n\\nLoopar includes several pre-built themes:\\n\\n| Theme | Description |\\n|-------|-------------|\\n| Default | Clean, professional blue |\\n| Slate | Neutral gray tones |\\n| Rose | Warm pink accent |\\n| Orange | Energetic orange |\\n| Green | Fresh green accent |\\n| Violet | Purple tones |\\n\\n---\\n\\n## Creating Custom Themes\\n\\nDefine a new theme in your app:\\n\\n```javascript\\n// Custom theme definition\\nconst myTheme = {\\n  name: \\\"corporate\\\",\\n  colors: {\\n    primary: { h: 210, s: 100, l: 40 },     // Corporate blue\\n    secondary: { h: 210, s: 20, l: 95 },\\n    accent: { h: 45, s: 100, l: 50 },        // Gold accent\\n    background: { h: 0, s: 0, l: 100 },\\n    foreground: { h: 210, s: 50, l: 10 },\\n  }\\n};\\n```\\n\\n---\\n\\n## Dark Mode\\n\\nDark mode is automatic based on:\\n\\n1. User preference in settings\\n2. System preference (`prefers-color-scheme`)\\n3. Manual toggle\\n\\n```jsx\\n// Toggle dark mode\\nimport { useTheme } from \\\"@loopar/components\\\";\\n\\nfunction ThemeToggle() {\\n  const { theme, setTheme } = useTheme();\\n  \\n  return (\\n    <button onClick={() => setTheme(theme === \\\"dark\\\" ? \\\"light\\\" : \\\"dark\\\")}>\\n      Toggle Theme\\n    </button>\\n  );\\n}\\n```\"}},{\"element\":\"markdown\",\"data\":{\"label\":\"Glossary\",\"key\":\"md_glossary\",\"id\":\"glossary\",\"name\":\"md_glossary\",\"value\":\"# Glossary\\n\\nQuick reference for Loopar terminology.\\n\\n---\\n\\n| Term | Definition |\\n|------|------------|\\n| **Entity** | The core model definition that generates database tables, APIs, and UI |\\n| **Builder** | Specialized entity type for creating specific model types |\\n| **App** | Self-contained application package with modules and entities |\\n| **Module** | Organizational unit that groups related entities |\\n| **Document** | Instance of an entity (a record in the database) |\\n| **Single** | Entity type that stores only one record (for settings/config) |\\n| **Tenant** | Independent site with own database and configuration |\\n| **Desk** | The admin interface for managing entities and data |\\n| **Component** | UI element used in drag-and-drop design |\\n| **Field** | Data attribute defined in an entity |\\n| **Hook** | Lifecycle callback (beforeSave, afterInsert, etc.) |\\n| **Controller** | Server-side class handling business logic |\\n| **Action** | Custom API endpoint defined in a controller |\\n| **Link** | Field type referencing another entity (foreign key) |\\n| **Table** | Field type for child records (one-to-many) |\\n| **PM2** | Process manager running all tenant sites |\\n| **Caddy** | Reverse proxy for SSL and domain routing |\\n\\n---\\n\\n## Common Patterns\\n\\n| Pattern | Example |\\n|---------|---------|\\n| Entity name | `Customer`, `Sales Invoice`, `Stock Entry` |\\n| Field name | `customer_name`, `total_amount`, `is_active` |\\n| Module name | `core`, `sales`, `inventory` |\\n| App name | `my-crm`, `loopar`, `hr-management` |\\n| Route | `/desk/Customer/list`, `/api/Customer` |\\n\\n---\\n\\n## File Extensions\\n\\n| Extension | Purpose |\\n|-----------|--------|\\n| `.json` | Entity/component definitions |\\n| `.js` | Server-side controller |\\n| `.jsx` | Client-side React component |\\n| `.env` | Environment configuration |\\n| `.mjs` | ES Module JavaScript |\"}}],\"imageProps\":{},\"style\":{}}]",
  "__ENTITY__": "Page Builder"
}